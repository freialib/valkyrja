var Promise = require('lie');
var SSH = require('simple-ssh');
var _ = { each: require('lodash.foreach') };
var c = require('chalk');

var is = {
	string: require('lodash.isstring')
};

var SSHWrapper = function (conf, host) {
	if (conf.ssh) {
		this._conf = conf.ssh;
	}
	else { // use sensible default
		this._conf = {
			timeout: 600000
		}
	}

	this._cmds = [];
	this._host = host;
	this._dryrun = false;
	this._disabled = false;
};

SSHWrapper.prototype = {

	dryrun: function () {
		this._dryrun = true;
	},

	addcmd: function (cmd) {
		this._cmds.push(cmd);
	},

	disable: function () {
		this._disabled = true;
	},

	isEnabled: function () {
		return ! this._disabled;
	},

	normalize: function (cmd, host) {
		_.each(host, function (value, key) {
			if (is.string(value)) {
				var tag = new RegExp('\\<\\<'+key+'\\>\\>', 'g');
				cmd = cmd.replace(tag, value);
			}
		});

		return cmd;
	},

	exec: function () {
		var self = this;

		if (this._disabled) {
			return Promise.resolve();
		}

		if (this._dryrun) {
			_.each(this._cmds, function (cmd) {
				var cmd = self.normalize(cmd, host);
				console.log(c.dim(cmd));
			});

			return Promise.resolve();
		}
		else { // ! dryrun

			var cmds = this._cmds;
			var host = this._host;
			var conf = this._conf;

			return new Promise(function (done, failed) {

				try {
					var tasks = [];
					var nextTask = function () {
						if (tasks.length > 0) {
							var task = tasks.shift();
							task().then(nextTask, failed);
						}
						else { // finished
							done();
						}
					}

					_.each(cmds, function (cmd) {
						var cmd = self.normalize(cmd, host);
						tasks.push(function () {
							return new Promise(function (resolve, reject) {
								try {
									console.log(c.dim(cmd));

									var ssh = new SSH({
										host: host.host,
										user: host.username,
										timeout: conf.timeout,
										baseDir: host.path,
										agent: process.env.SSH_AUTH_SOCK,
										agentForward: true
									});

									ssh.exec(cmd, {
										out: function (stdout) {
											process.stdout.write(stdout);
										},
										err: function (stdout) {
											process.stdout.write(stdout);
										},
										exit: function (code) {
											if (code != 0 || code != '0') {
												console.log(c.red.dim('command failed') + ', code ' + code);
												console.log('');
												if (conf['stop-on-errors']) {
													reject(null);
												}
												else { // we don't stop on errors
													resolve();
												}
											}
											else {
												resolve();
											}

											return false;
										}
									});

									ssh.on('error', function (err) {
										console.log(c.red.dim('an error has occured'));
										console.log('');
										if (err.stack) {
											console.log(err.stack);
											console.log('');
										}
										else { // non-stack error
											console.log(err);
											console.log('');
										}
										ssh.end();
										reject(null);
									});

									ssh.start();

								}
								catch (e) {
									reject(e);
								}

							});
						});
					});

					nextTask();

				}
				catch (e) {
					failed(e);
				}
			});
		}
	}

};

module.exports = function (conf, host) {
	return new SSHWrapper(conf, host);
}
